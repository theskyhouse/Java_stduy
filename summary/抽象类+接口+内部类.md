# 代码仅仅是思想的体现

[TOC]

#### 抽象类

- 方法只有声明没有实现，该方法就是抽象方法。用abstract修饰

  （抽象方法必须定义在抽象类中，该类被abstract修饰）

- 抽象类不能被实例化，调用抽象方法没有意义
- 抽象类----子类必须重写所有方法，才可以实例化，不然这个子类也是抽象类（拥有抽象方法）

1.  抽象类中有构造函数---给子类对象初始化
2. 抽象类中可以不定义抽象方法---不让该类创建对象  （通常这个类中的方法有方法体 但是没有内容）
3. 抽象类不能用static（通过类名直接调用  抽象方法没意义）、private 、final
4.   抽象类中不仅可定义抽象方法，同时也可以定义非抽象方法
5. 抽象类一定是父类，需要子类重写方法才可以实例化

------

#### 接口

对于接口中常见的成员都有固定的修饰符

全局变量（不可修改）：public static final （接口中的变量会被隐式定义为全局变量）

抽象方法 public abstract 

- 接口不可以实例化。只有实现了接口的子类重写接口中所有抽象方法后，该子类才能实例化。（否者这个子类带有抽象方法，是一个抽象类）
- 接口与接口之间是继承关系，**接口可以实现多继承！**（interface C extends A, B ）



关于接口：举个例子

狗这个类继承了走兽类，它有跑，跳，啃，等方法。但是它不会飞，它的父类也没有这个方法。但是你想让狗有飞这个功能，怎么办呢？当然你可以直接在狗的类中给它添加一个飞的方法就行了。有可能你并不会写这个方法，或者是这个方法需要几千几万行代码，硬写吗？那以后你还想要猪，牛，羊等等都可以飞呢？那又怎么办呢？这时候你发现你有一个类，这个类就叫飞行兽吧。它有一个方法就是飞行，这下好了，你决定让狗继承它，结果发现不能多继承，你又想让狗的父类继承它，结果发现还有其他的走兽不能让他们飞。这时候就需要接口出来了，这个接口我们叫它插翅膀吧，这个接口有一个方法就是插翅膀，但没有实现，因为接口不管你怎么给狗插翅膀。同时你还发现在飞行兽里有一个带参数的构造方法，而参数类型就是这个接口类型。但是狗的类型是狗而不是接口类型，没法作为参数传进去，这时你就可以让狗实现这个接口，这个狗对象就成了插了翅膀的狗，接着通过多态的原理把插了翅膀的狗这个对象传给飞行兽，这狗这就成了飞行兽，可以飞了。

------

#### 不同点

1. 抽象类需要被继承，只能单继承。接口需要被实现，可以多实现。
2. 抽象类中可以有非抽象方法，子类继承后，可以直接使用非抽象方法。接口只能定义抽象方法。（接口可以看成只有抽象方法的抽象类）
3. 对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。
4. 抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。
5. 接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；
6. 抽象类可以继承实体类 ，前提是实体类必须有明确的构造函数

（Object其实就是个实体类  所有类都直接或渐渐继承Object）

```
借用一段网上的代码来说明
interface Alram {
    void alarm();
}//警报的接口

abstract class Door {
    void open();
    void close();
}//抽象类----门

class AlarmDoor extends Door implements Alarm{
    void oepn() {
        //....
    }
    void close() {
        //....
    }
    void alarm() {
        //....
    }
} //警报门继承了门这个抽象类 同时通过实现警报这个接口来实现警报
open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。
有些门不一定具备警报功能（因此用接口）但是门都具备抽象类door的属性和方法
```

------

#### 内部类

作用

1. 更好的实现隐藏

   ```java
   public interface jiekou{
       void increment();
   }
   //具体类
   public class Example{
       private class xw implements jiekou{
           public void test(){
               System.out.println("tese!");
           }
       }
       //可以返回接口，接口虽然不能被实例化，但是接口的实现类都可以向上转型为接口。表面上返回的是接口，其实返回的是接口的实现类。
       public jiekou getIn(){
           return new xw();
       }   
   }
   
   //客户端
   public class test{
       public static void main(String args[]){
           Example a=new Example();
           jiekou b=a.getIn();//（引用类型也有接口返回的是接口实现类对象）
           b.test();
       }
   }
   
   //  我们不知道xw这个类的名字，所以有个隐藏的功能
   ```

   

2. 可以无条件的访问外围类的所有元素（前提是内部类非静态，静态内部类缺少指向外围类的引用）

3. **可以实现多继承**

   ```java
   //先来定义两个类
   class xw1{
       public String name(){
           return "lxw";
       }
   }
   
   class xw2{
       public int age(){
           return 20;
       }
   }
   
   //实现多继承
   public class  Main{
       //写两个内部类分别继承类一和类二
       private class test1 extends xw1{
           public String name(){
               return super.name();
           }
       }
   
       private class test2 extends xw2{
           public int age(){
               return super.age();
           }
       }
   
       public String name(){
           return new test1().name();
       }
   
       public int age(){
           return new test2().age();
       }
   
       public static void main(String args[]){
           Main xw=new Main();
           System.out.println("name is "+xw.name());
           System.out.println("age is "+xw.age());
       }
   
   }
   
   
   //主类中 两个内部类分别继承了 类一和类二 这样我们的Main类就同时拥有了两个类的方法和属性  间接实现了多继承
   ```

   

4. 避免修改接口而实现同一个类中两种同名方法的调用

   （实现接口和继承的类中有两个同名方法）

   我们可以用内部类来实现接口，避免和外围类的方法冲突

------

